<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head><meta http-equiv="content-type" content="text/html;charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
body {line-height: 1.5; padding: 4em 1em;}
h2 {margin-top: 1em; padding-top: 1em;}
.cl{border-style:solid; border-width:1px; text-align:center; width:100px;} .cl a {text-decoration:none;}
.dl{border-style:solid; border-width:1px; text-align:center; width:50px;}
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; }
td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; } td.sourceCode { padding-left: 5px; }
.sourceCode span.kw { color: #007020; font-weight: bold; } .sourceCode span.dt { color: #902000; } .sourceCode span.dv { color: #40a070; } .sourceCode span.bn { color: #40a070; } .sourceCode span.fl { color: #40a070; } .sourceCode span.ch { color: #4070a0; } .sourceCode span.st { color: #4070a0; } .sourceCode span.co { color: #60a0b0; font-style: italic; } .sourceCode span.ot { color: #007020; } .sourceCode span.al { color: red; font-weight: bold; } .sourceCode span.fu { color: #06287e; } .sourceCode span.re { } .sourceCode span.er { color: red; font-weight: bold; }
</style>
<title>Документация к FCEUd #2</title>
<link rel="icon" type="image/png" href="../../files/favicon.png" />
</head><body>
<div style="position:absolute; top:0; bottom:0; left:0; width:25%; text-align: right">
<img src="../../files/head.svg" width="90%" alt="SVG not supported" /></div>
<div style=" margin: 0 auto; font-size: medium; width: 50%; text-align: justify; color: black; font-family: 'Georgia', serif;">
 <table cellpadding="3" cellspacing="3"><tbody><tr> 
 <td class="cl">  <a href="../../">NEWS</a> </td>
 <td class="cl">  <a href="../../doc/">ARTiCLES</a> </td>
 <td class="cl">  <a href="../../passgen/">PASSGENS</a> </td>
 <td class="cl">  <a href="../../archive.html">ARCHiVE</a> </td>
 <td class="cl">  <a href="../../about.html">ABOUT</a> </td>
 </tr></tbody></table>
 <h1>Документация к FCEUd #2</h1>
<ol style="list-style-type: decimal">
<li><strong>Разминка</strong><br />
Перед тем как начать, лучше сразу сказать, что нужно знать, чтобы полностью понять этот документ. Во-первых, нужно знать основы программирования на ассемблере. (Основы просты: нужно понимать каждую команду и режимы адресации команд). Так же нужно быть сведущим в двоичной системе счисления, включая и вычисления в ней. В общем, для того чтобы начать пользоваться FCEUd нужно не так много. Документы по ассемблеру процессоров семейства 6502 и разные доки можно найти на Zophar Domain и ROMHacking.net. Или просто используйте поиск со словами “6502 Assembly” в Гугле. То, что нам понадобится:
<ul>
<li>FCEUd</li>
<li>РОМ игры The Addams Family: Pugsley’s Scavenger Hunt,</li>
<li>Разные доки, которые можно найти на: www.zophar.net/, www.obelisk.demon.co.uk/6502/reference.html, www.romhacking.net/</li>
</ul></li>
<li><p><strong>Находим пароль</strong><br />
Первое что надо сделать при вскрытии алгоритмов паролей - это найти введённый пароль в RAM! Для этого можно воспользоваться простым поиском читов. Откроем ром и перейдём на экран ввода пароля. Здесь вводим однин знак “1” (чтобы ввести знак пароля нужно будет нажать А). Затем открываем окно читов в FCEUd через меню NES -&gt; Cheats… С открытым окном читов кликнем Add Cheat(добавить Чит), чтобы открыть Консоль Читов. Здесь вы видите чит сёрч - то, что поможет нам найти введённый пароль в RAM. При начале чит поиска в первую очередь нужно нажать кнопку Reset Search ( Сброс Поиска ). После этого стираем введённую единицу кнопкой B и вводим “2”. Возвращаемся к окну поиска читов и выбираем фильтр “O!=C”. Это означает, что исходное значение ( Original ) не равно текущему ( Current ). Нажмем кнопку “Do search”( произвести поиск ), а потом “Set Original To Current”( установить текущее значение в исходное ), В консоле читов FCEUxd и FCEUXDSP последнее действие проделывается автоматически при нажатии “Do search”. и вернёмся к игре. Теперь вводим три “1”, так что теперь пароль стал “2111”.Вернёмся к читам и поставим фильтр “|O-C|==V2”. Это означает, что разница между исходным и текущимизначениями равна V2. Значение V2 можно вписать в окно слева от фильтров - не пропустишь! В нашем случае V2 должно содержать ноль, потому что первый знак пароля не изменился с момента предыдущего поиска. Нажмём “Do search” ещё раз, потом вернёмся в игру и введём первым знаком пароля “Z”. Теперь нужно будет установить фильтр “O!=C”, так как значение изменилось. Жмем ещё раз на поиск, и так далее пока не остановимся на единственно возможном адресе. Забегая вперёд, могу сказать, что это $043D.</p></li>
<li><p><strong>Находим алгоритм проверки пароля</strong><br />
Итак, теперь когда мы знаем где пароль хранится в RAM, нам нужно использовать эти знания чтобы найти код, отвечающий за проверку пароля. Он должен проверить не является ли введённый пароль случайными знаками!<br />
Открываем консоль отладки FCEUd через NES -&gt; Debug, или нажав F1. Теперь вернёмся в игру и введём случайный пароль, например “2211B”. Но перед тем как ввести последнюю букву, установим останов на чтение (BPR) из адреса $043D. Исполнение программы тут же останавливается, так что будем работать в области этой команды. Деактивируем BPR перед тем как продолжить.<br />
С остановленной игрой поставим останов на запись (BPW) в $0441. Это ячейка, в которой содержится наш последний знак пароля. Наконец, вводим последний знак и отладчик остановит выполнение программы из-за второго останова. Его теперь можно удалить - он нам не пригодится. Активируем первый останов и нажмём “Run”! Мы окажемся прямо посреди подпрограммы, отвечающей за расшифровку пароля, с которой и надо разобраться, чтобы написать генератор паролей!<br />
В окне дизассемблера прокрутим вверх пока не встретим первую команду RTS. К счастью, она в строке прямо над адресом PC. Это означает, что программный счётчик (PC) установлен на начало подпрограммы. Так что можно скопировать весь код, начиная с начала подпрограммы и заканчивая первым RTS который встретится. Просто вставим его в блокнот и реверснём его!</p></li>
<li><p><strong>Переводим 6502 в Си или другой язык</strong><br />
Начинается весёлая часть - непосредственно делаем генератор паролей! Я в первую очередь просто поверхностно просматриваю полученный код. Сразу видны знакомые адреса, которые содержат введённый пароль. Это хорошо.Теперь взглянем на подпрограмму по маленьким частям.</p>
<pre><code>$BAC8:AD 3D 04 LDA $043D = #$01
$BACB:18 CLC
$BACC:6D 3E 04 ADC $043E = #$01
$BACF:18 CLC
$BAD0:6D 3F 04 ADC $043F = #$00
$BAD3:18 CLC 
$BAD4:6D 40 04 ADC $0440 = #$00 
$BAD7:18 CLC 
$BAD8:69 25 ADC #$25 
$BADA:29 1F AND #$1F 
$BADC:CD 41 04 CMP $0441 = #$09 
$BADF:D0 3A BNE $BB1B </code></pre>
<p>Очень простой код. Он загружает первый знак пароля из $043D, потом добавляетэто значение к значениям других трёх знаков пароля. Это самая распространённая из всех чексумм, но дальше эта игра делает что-то другое. После создания чексуммы, она прибавляет $25 к этой величине, чтобы немного её изменить. Наконец, она маскирует её $1F (наибольший знак, который может встретиться в пароле). А потом игра просто сравнивает получившуюся чексумму с последним знаком в пароле. Если они совпадают, то она ветвится в $BB1B.<br />
Проверьте скопированный код, убедитесь, что в нём есть команда по адресу $BB1B. Его может не быть, если вы закончили копировать на первом RTS. $BB1B - очень небольшой кусок кода, который просто возвращает -1, что означает ошибку ( вывод на экран надписи ERROR ).</p>
<pre><code>$BB1B:A9 FF LDA #$FF 
$BB1D:60 RTS </code></pre>
<p>Только и всего!<br />
Итак, запомнив всё это, давайте напишем часть программы, выполняющую точно такие же действия как и тот код сверху. Я буду использовать Си, так как это мой любимый язык программирования.<br />
<img src="code1.png" alt="code1.png" /><br />
Довольно просто, не так ли?<br />
Дальше мы взглянем на следующий кусок кода, который уже несколько сложнее.</p>
<pre><code>$BAE1:AD 3D 04 LDA $043D = #$01 
$BAE4:49 0A EOR #$0A 
$BAE6:0A ASL
$BAE7:0A ASL 
$BAE8:0A ASL 
$BAE9:0A ASL 
$BAEA:8D 3B 04 STA $043B = #$00 
$BAED:AD 3E 04 LDA $043E = #$01 
$BAF0:49 0F EOR #$0F 
$BAF2:4A LSR 
$BAF3:0D 3B 04 ORA $043B = #$00 
$BAF6:8D 3B 04 STA $043B = #$00 
$BAF9:29 02 AND #$02 
$BAFB:D0 1E BNE $BB1B </code></pre>
<p>Загружается первый знак пароля, затем он XOR’ится с $0A, и четыре раза логически сдвигается влево. Затем он временно сохраняется, а загружается второй знак пароля, который XOR’ится c $0F. Наконец, значение сдвигается вправо один раз, после чего оно OR’ится с предыдущим полученным занчением. Кроме того, есть небольшая проверка на то выставлен ли первый бит. Если бит равен единице, то подпрограмма возвращает ошибку ( зачем нужна эта проверка - см. ниже ).<br />
<img src="code2.png" alt="code2.png" /><br />
Потом вы увидите почему я использовал массив. Обычно я прогоняю алгоритмы несколько раз, перед тем как перевести их. Следующий кусок кода намного проще и требует намного меньше работы.</p>
<pre><code>$BAFD:AD 3F 04 LDA $043F = #$00 
$BB00:49 05 EOR #$05 
$BB02:8D 37 04 STA $0437 = #$00 </code></pre>
<p>Загружается третий знак, XOR’ится с $05, сохраняется в буффер!<br />
<img src="code3.png" alt="code3.png" /> Видите?! Так просто!!</p>
<pre><code>$BB05:AD 40 04 LDA $0440 = #$00 
$BB08:49 02 EOR #$02 
$BB0A:4A LSR 
$BB0B:8D 38 04 STA $0438 = #$05 </code></pre>
<p>Загружает четвёртый знак, XOR’ит с $02, сдвигает один раз вправо и сохраняет в буффер!<br />
<img src="code4.png" alt="code4.png" /><br />
Остаток алгоритма по большей части бесполезен, так что его можно смело проигнорировать. Всё что он делает, так это просто заполняет какие-то ячейки памяти.</p></li>
<li><p><strong>Собираем всё вместе</strong><br />
Всё что осталось сделать, это собрать всё это вместе в одну программу и у нас будет полнофункциональный контролёр паролей. Ну это, конечно, здорово, но ведь нам нужна программа, которая генерирует пароли, а не проверяет их! Как наша задача соотносится с тем что мы написали? В 9 из 10 случаев, ответ будет “РЕВЕРСИРОВАТЬ!” Да, точно: возьмите программу и перепишите её с точностью до наоборот. Например, вот полная функция проверки пароля.<br />
Надеюсь, вы поняли как я перевернул программу. Всё нужно делать наоборот: например, вместо прибавить нужно вычитать. Обратите внимание на маску, которую я сделал для password[1]. Эти команды просто предотвращают превышение максимальновозможного занчения знака пароля ($1F). В большинстве случаев применять такие сложные действия проделывать и не придётся: куда легче будет дойти до того места, где происходит генерирование пароля самой игрой и немного подсмотреть алгоритм ;)<br />
Теперь просто соберём это всё в милую программку и готово!</p></li>
<li><p><strong>Понимание Данных</strong><br />
Секрет изготовления своего генератора паролей в понимании данных, изымаемых из знаков пароля. Я просто сравнивал данные буфферов (buffer) с предметами, которые мне давали. Вкратце: buffer[0] - десятки жизней героя, buffer[1] - единицы жизней героя и, наконец, в buffer[2] хранятся данные о числе сердец и спасённых членах семьи.<br />
Эта секция обычно доставляет наибольшие проблемы начинающим. Ну с жизнями ещё куда не шло: можно скомпилировать генератор, подставить в значения буферов какие-то числа и посмотреть результат. Жизни видно сразу без напряжения. А вот со вторым буфером я в свое время так и не разобрался: исписал два листа вдоль и поперёк всевозможными комбинациями, но так и не понял принципа. Всё дело в “битовой логике”. Логические операции с битами очень часто используются для хранения данных в пароле. Ну, конечно, далеко не только для этого (взгляните в любое место кода любой игры на NES (да вообще, в любой ассемблерный листинг) - везде логические операции). Это основы, которыми просто необходимо овладеть. Для тех кто до сих пор не подозревал о существовании логических операций рекомендуется почитать вот эту записку. В дальнейшем будем исследовать ячейку, содержащую decode[2] ($043B). Поставим останов на чтение из ячейки, обозначенной нами как decode[2], и посмотрим как же её используют после формирования из данных пароля.</p>
<pre><code>$C6F6:AD 3B 04 LDA $043B = #$04  
$C6F9:A2 02 LDX #$02(две жизни есть всегда!) 
$C6FB:0A ASL 
$C6FC:90 01 BCC $C6FF 
$C6FE:E8 INX 
$C6FF:0A ASL 
$C700:90 01 BCC $C703 
$C702:E8 INX 
$C703:0A ASL 
$C704:90 01 BCC $C707 
$C706:E8 INX 
$C707:8E 36 04 STX $0436 = #$03; число возможных жизней(доступны, но не заполнены) 
$C70A:8E 35 04 STX $0435 = #$02; число заполненных жизней </code></pre>
<p>Как видите, заполненные жизни всегда будут равны возможным, потому что запись восстанавливает жизни. Судя по коду, наибольшее возможное число - 5, скажем, если decode[2] равен $E0. Так и есть - в игре максимум пять сердец. Почему-то при загрузке уровня произошло только такое использование этого байта. Куда же ушли остальные (пока не использованные) пять бит?! Может из ячейки будут читать, когда уже надо выводить информацию о тех, кого спас герой, т.е. при нажатии на паузу? Останов произошел по адресу B8С4, однако там страшная процедура, разобраться в которой под силу только далеко не начинающему хакеру. А так как мы не из таких, то легче, а самое главное, быстрее будет просто подставлять нужные нам неизвестные пять бит в память приставки и посмотрим что будет. Подставляем и нажимаем на паузу - данные пересчитываются.<br />
Итак:<br />
младший бит: Гомез<br />
бит 1: Мортиша (см. ниже)<br />
бит 2: Дядя Фестер<br />
бит 3: Бабуля<br />
бит 4: Венздей<br />
Остаётся вопрос: почему же игра так упорно не желает, чтобы пароль хранил информацию о спасении Мортиши? Посмотрите на команду</p>
<pre><code>$BAF9:29 02 AND #$02
$BAFB:D0 1E BNE $BB1B  </code></pre>
<p>Проверяет спасена ли Мортиша и если да, то выводит сообщение о неправильном пароле - пароля со спасенной женой Гомеза не должно существовать. Те кто проходил игру знают, что она нелинейна: родственников можно спасать практически в любом порядке, однако последней всегда должна быть Мортиша, т.к. дверь, за которой она заточена, и где скрывается финальный босс - Судья, заперта до тех пор, пока герой не спасёт всех остальных. Нам повезло, что информация о героях считывается во время паузы, а не во время анализа пароля, потому что если бы мы вписывали значения до принятия пароля, то он бы просто не был принят (разумеется, если мы не поменяем код ;))<br />
Для тех, кому интересно “а что будет, если…” могу сообщить: если ввести пароль, в котором все родственники, включая Мортишу будут спасены и вновь придти к Судье, то можно будет наблюдать такую безобразную картину:<br />
<img src="addamspwd.png" alt="addamspwd.png" /><br />
Судья неподвижен, и кроме него и Пагсли ничего больше не загружается. Более того, очевидно, код, который проверяет спасена ли Мортиша используется прямо во время поединка, так что подтасовывая байты в ячейке можно периодически заставлятьсудью вставать, а уровень - становиться опустошённым. А что касается того пароля, который выдаётся по окончании игры, то это обычный пароль с четырьмя спасёнными членами семьи (Мортиша опять в заточении), и не понятно зачем он вообще нужен.</p></li>
</ol><hr />
</div></body></html>