<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head><meta http-equiv="content-type" content="text/html;charset=UTF-8" />
<title>Цвета и палитры NES</title>
<link rel="stylesheet" type="text/css" href="../../css/style.css" />
<link rel="stylesheet" type="text/css" href="../../css/syntax.css" />
</head>
<body>
<div id="sidebar"><img src="../../files/head.svg" alt="SVG not supported" /></div>
<div id="nav">
<table cellpadding="3" cellspacing="3"><tbody><tr> 
<td class="cl">  <a href="../../">NEWS</a> </td>
<td class="cl">  <a href="../../doc/">ARTiCLES</a> </td>
<td class="cl">  <a href="../../passgen/">PASSGENS</a> </td>
<td class="cl">  <a href="../../archive.html">ARCHiVE</a> </td>
<td class="cl">  <a href="../../about.html">ABOUT</a> </td>
</tr></tbody></table></div>
<div id="content">
	<h1>Цвета и палитры NES</h1>
<ol style="list-style-type: decimal">
<li><strong>Разминка</strong><br />Перед тем как начать, лучше сразу понять, что нужно знать, чтобы полностью понять этот документ. Во-первых, нужно знать основы программирования на ассемблере. (Основы просты: нужно понимать каждую команду и режимы адресации команд). Так же нужно быть сведущим в двоичной системе счисления, включая и вычисления в ней. В общем, для того чтобы начать пользоваться FCEUd нужно не так много. Документы по ассемблеру процессоров семейства 6502 и разные доки можно найти на Zophar Domain и ROMHacking.net. Или просто используйте поиск со словами “6502 Assembly” в Гугле.<br />То, что нам понадобится:
<ul>
<li>Лично я использую FCEUxdSP, однако можно также взять FCEUxd или FCEUd<br /></li>
<li>РОМ игры Bucky O’Hare,<br /></li>
<li>Разные доки, которые можно найти на: www.zophar.net/, tv-games.ru, www.romhacking.net/<br /></li>
</ul></li>
<li><strong>Теория</strong><br />Как уже повелось, начнём с теории рассматриваемого вопроса. Далее я опишу только самые основы, которые понадобятся нам в дальнейшем. Более подробно в техническом плане о палитрах и атрибутах можно будет прочитать в таких замечательных документах, как Nintendo Entertainment System Architecture by Marat Fayzullin; Архитектура и программирование Dendy. MiGeRA S0ftWareZ; Статья из журнала GameBit #7 ‘Палитровые эффекты’ Zephyr’а.<br />NES имеет две 16-тицветных палитры: для изображений(фон и т.д.) и вторая для спрайтов. В памяти PPU они располагаются по адресам $3F00 и $3F10 соответственно. Понятие палитры подразумевает, что в памяти хранятся RGB характеристики цвета. На NES цвета заготовлены заранее, поэтому палитрами всё это можно назвать лишь условно: каждому цвету поставлено в соответствие некоторое числовое значение. Всего возможных цветов 64. Для наглядности приведём таблицу цветов и соответствующихим значений:<br /><img src="nes_rgb.png" alt="nesRgb" /><br />По таблице можно видеть, что в байте палитры используются только 6 младших бит: четыре младших бита характеризуют оттенок, а два старших - яркость Палитры хранятся по адресам: $3F00-$3F0F для палитры картинок; $3F10-$3F1F для спрайтовой палитры. Как мы видим, палитра занимает место в 16 байт, соответственно в каждой палитре будет по 16 цветов. Те, кто хоть раз рисовал в графических редакторах для игр на Денди, хорошо помнят, что раскрашивать картинку можно только в четыре цвета. Откуда же тогда 16? Действительно и на экране можно встретить гораздо больше, чем 4 цвета. Для простоты, можно всё представить так: вся палитра разбивается по порядку на четыре части (по 4 цвета в каждой) и некоторому блоку (размером 2*2 тайла) может быть присвоен свой номер части палитры. За такое присвоение отвечает таблица атрибутов. О ней чуть позже.<br />Итак, палитра - это фактически совокупность из 16 байт, каждый из которых показывает какой цвет нужно вывести на экран. В первой части палитры в качестве первого цвета хранится номер холста, который будет просвечивать через прозрачные цвета, во второй части палитры первый цвет указывает на то,какой цвет в этой части будет прозрачным, в третьей части первый цвет указывает на то, какой цвет в этой части будет прозрачным, и так далее. Таким образом, с точки зрения вывода цвета на экран, первые цвета во второй третьей и четвёртой частях палитры будут абсолютно бесполезны, так как они заменяются на цвет холста.Так вот - архитектура PPU Денди предусматривает отражение “лишних” ячеек палитры ($3F04, $3F08 и $3F0C) в ячейку цвета холста ($3F00). И на экране возможны не 16, а уже 13 различных цветов, что в совокупности с цветами спрайтов могут дать 26 уникальных цветов на экране. Надеюсь, это понятно.<br />Теперь об атрибутах. Таблицы атрибутов картинок (про спрайтовые атрибуты будет поведано в разделе Спрайтовых палитр) хранятся в памяти PPU сразу после соответствующей тайловой карты, таким образом, можно выделить 4 таблицы по числу тайловых карт. Размером каждая таблица по 64 байта (например, таблица атрибутов для первой тайловой карты будет расположена по адресу $23C0-$23FF, а в $2400 уже расположена вторая тайловая карта). Каждый байт таблицы атрибутов отвечает за 16 тайлов, соответственно, каждые два бита отвечают за группу из четырёх тайлов. Нагляднее всего этот вопрос раскрыт в документе MiGeR’ы. Байт области атрибутов по адресу $23C0. Содержит атрибуты четырех смежных групп. Цветом указано соответствие атрибутов группам.<br />Таким образом, два бита дают нам номер группы в общей палитре. Например, байт $AA в таблице атрибутов или 10101010b раскрасит квадрат из 16 тайлов в цвета третьей палитровой группы (т.к. 10b = 2, но не стоит забывать и про то, что первая группа будет определяться 00b, т.е. логичнее её называть нулевой группой). соответственно последняя (четвертая группа) будет соответствовать 11b.<br /></li>
<li><p><strong>Фоновые Палитры</strong><br />Честно говоря, идея этого документа родилась, когда я вдруг в своих РОМсетах обнаружил перевод Шедевра игры Bucky O’Hare . Про перевод ничего говорить не буду - у меня другая цель. Моё внимание привлёк титульный экран: <img src="Pal1.png" alt="Pal1" /><br />Сначала когда я увидел российский триколор, я сразу подумал, что уже в те далёкие времена ромхакеры могли не пожалеть времени и изменить палитру ради патриотических чувств. =) Однако сравнив палитры в оригинале и изменённом РОМе можно легко убедиться, что в этом случае переводчику просто необычайно повезло: сама палитра удивительным образом совпадает с цветами российского флага (просто в оригинале синий цвет в надписи ‘Palcom’ не используется). На этом предисловие заканчивается и начинаются суровые будни. Не так давно для нахождения палитр вам можно было смело посоветовать искать их с помощью Nesticle(которая, лично у меня, не пустилась даже под DosBox’ом), а потом искать последовательность байт с помощью хексредактора. В документе ‘Palette Modifications of an NES file using a Hex Editor’ by aStROcReEp вообще советуют обозначить каждый цвет буковкой, составить таблицу и искать сочетания этих буковок. Эти методы подходят начинающим, однако требуют диких затрат времени и могут не сработать(скажем, когда индексы цветов загружаются из операндов команд). Сейчас ситуация в корне изменилась - появился FCEUxd(FCEUxdsp). Гарантировано идёт под 32-разрядными Windows и имеет удобный хексредактор. Итак, быстрый способ нахождения палитр. Открываем в нашем замечательном отладчике указанный выше РОМ. Ставим останов на запись данных в палитру картинки по адресу $3F00 в PPU непосредственно перед загрузкой нашего титульника и дожидаемся его загрузки. Останов сработал:</p>
<pre><code>$D5DF:8D 07 20 STA $2007 = #$00
$D5E2:B9 20 01 LDA $0120,Y @ $0124 = #$27 
$D5E5:C8 INY 
$D5E6:C9 FF CMP #$FF 
$D5E8:D0 F5 BNE $D5DF</code></pre>
<p>В аккумуляторе $0F- чёрный цвет холста. Скорее всего, перед нами подпрограмма, которая выводит Y значений в память PPU, а значения берутся из ячеек, начиная с $0123. Отследим запись в эту ячейку. Поставим останов на запись опять же перед загрузкой титульного экрана. Останов срабатывает дважды в одном и том же месте. С точки зрения рассмотрения алгоритма нам всё равно, какой раз брать.</p>
<pre><code>$C54D:85 0B STA $000B = #$08
$C54F:A0 00 LDY #$00
$C551:A9 0F LDA #$0F 
$C553:9D 20 01 STA $0120,X @ $0123 = #$0F
$C556:E8 INX 
$C557:A9 03 LDA #$03 
$C559:85 0A STA $000A = #$00 
$C55B:B1 08 LDA ($08),Y @ $96AB = #$27 
$C55D:9D 20 01 STA $0120,X 
$C560:E8 INX 
$C561:C8 INY 
$C562:C6 0A DEC $000A 
$C564:D0 F5 BNE $C55B 
$C566:C6 0B DEC $000B 
$C568:D0 E7 BNE $C551 
$C56A:60 RTS</code></pre>
<p>Подпрограмма вывода всей палитры во всей своей простоте и изяществе! $000B - общий счётчик введённых индексов цветов; $000A - частный счётчик цветов в каждой части палитры (мы же ведь не забыли, что палитра условно разбивается на четыре части?) В ячейках $08 и $09 содержатся указатели на палитру, которые в случае чего можно/нужно будет поменять. $96AB - адрес в RAM, содержащий второй индекс цвета в первой части палитры. Второй, потому что первый загружается из операнда команды по адресу $C551.<br />Сразу видно преимущество этого метода: в РОМе хранятся только 2,3 и 4-й цвета, а первый всегда $0F. Следовательно, если бы мы воспользовались советами тех документов, что были написаны для начинающих The Palette Hacking Doc by Toma; Palette Modifications of an NES file using a Hex Editor; The newbie NES Pallete hacking Tutorial. by Dark X; NES Palette hacking: The Fast Way (using FCEUd), мы должны были найти во вкладке ‘Tools -&gt; PPU Viewer…’ нашу загруженную палитру, потыкать в каждый цвет мышкой и записать на листочке байты: $0F $27 $16 $20 $0F $27 $14 $03… и попытаться найти их в РОМе. Понятно, что в нашем РОМе первого, пятого,девятого и тринадцатого $0F быть не может. С точки зрения начинающего - палитра ненаходима и/или зажата страшным алгоритмом!<br />Теперь воспользуемся преимуществами хексредактора FCEuXD: откроем редактор и найдём адрес $96AB, правой кнопкой мыши -&gt; Go Here In Rom File, и вот он наш адрес: $116BB. Для проверки поменяем палитру. Впишем по адресу $116с1 (судя по PPU Viewer’у надпись использует именно третью палитру) значения других цветов. Например, сочетание $28 $05 $00 даст нам цвета германского флага:<br /><img src="Pal2.png" alt="Pal2.png" /><br />Faterland uber alles! =)<br />В принципе, можно поменять и фон холста (подредактировав команду по адресу $C551), например:<br /><img src="Pal3.png" alt="Pal3.png" /><br />Однако, практической выгоды это не несёт, так как всё, что было прозрачным теперь стало этого цвета. Даже космос стал… голубоватым.<br /><img src="Pal4.png" alt="Pal4.png" /><br />Возникает вопрос: как можно использовать в наших корыстных целях таблицу атрибутов? Один из вариантов - присвоить участку экрана другую часть палитры (скажем, если нам не желательно изменять старую палитру), или даже присвоить участку ранее не встречавшиеся цвета.<br />Для примера предположим, что нам нужно, чтобы в надписи bucky o’hare слово bucky было зелёного цвета (как и сам главный герой). Однако в исходных частях палитры зелёного цвета нет! Зрячие также могут увидеть, что в четвёртую палитру загружены только цвета холста, т.е. она пустая. Вот и выход: вписать вместо $0F нужные нам цвета, а затем переназначить ту часть таблицы, что отвечает за наше слово со второй части палитры на четвёртую.<br />Как вписать нужные цвета (среди которых должен быть один зелёный) в палитру - смотри выше. А вот таблица атрибутов может быть найдена следующим образом (для наглядности я возьму довольно долгий способ). Доходим до титульника, открываем Hex Editor, выбираем PPU Memory, находим адрес первой таблицы атрибутов ($23c0) и начинаем запарывать байты поочерёдно (скажем, вписывать в ячейки байт FF, так как он не встречается в нашей таблице). В результате в самом эмуляторе мы увидим, что определённые квадраты начинают окрашиваться необычно. Таким образом, можно вычислить адреса, отвечающие за наше слово (в нашем случае это $23d0-$23D7). Соответственно, ставим останов на запись в эту область PPU и дожидаемся загрузки титульного экрана.</p>
<pre><code>$C677:8D 07 20 STA $2007 = #$00 
$C67A:88 DEY 
$C67B:D0 FA BNE $C677 </code></pre>
<p>Очевидно, здесь байт рома записывается в PPU столько раз, сколько будет в Y. Если так можно сказать, метод, похожий на RLE сжатие. Находим место, откуда берётся значение аккумулятора: Нажимаем несколько раз Step Into, пока Y не станет равным нулю, после операций над ячейками $00 и <span class="math">$01 (там хранятся указатели) программа загружает следующее значение в нашу таблицу атрибутов:   ``` $</span>C643:A0 00 LDY #<span class="math">00</span>C645:B1 00 LDA ($00),Y @ $81A4 = #<span class="math">01</span>C647:C9 FF CMP #<span class="math"><em>F</em><em>F</em></span>C649:F0 3E BEQ <span class="math"><em>C</em>689</span>C64B:C9 7F CMP #<span class="math">7<em>F</em></span>C64D:F0 32 BEQ <span class="math"><em>C</em>681</span>C64F:A8 TAY ``` Y берётся из ячейки $81A4, соответствующей $101b4, а значит вначале значения загружались из $101b2 (мы же не забыли, что продвинулись по программе вперёд?). Даже визуально можно определить, что сначала идёт байт-счётчик ($0E), затем атрибут ($55), который будет записываться $0E раз. Заметьте, что атрибут соответствует 01010101b, а значит, будет указывать на вторую палитру. Далее идёт атрибут $11, который вписывается один раз - он соответствует буковкам ‘TM’ после нашей надписи - они белые.<br />Перед нами стоит задача: разбить нашу надпись на две части (как видите, вся надпись обладает одним атрибутом, который загружается одним байтом) и переназначить атрибут на четвертую часть палитры. Если быть кратким, то это делается заменой байт по адресу $101b2 на $08 $FF $08 $55. Обратите внимание, что тогда буквы ТМ станут принадлежать второй части палитры (как и слово ‘O’Hare’) и станут фиолетовыми, но, думаю, чем-то нужно будет обязательно пожертвовать. Зато теперь мы добились нужного эффекта - верхнее слово можно будет раскрасить в нужный нам цвет.<br />Вот, например, что можно сделать с титульником, если подредактировать таблицу атрибутов как было указано выше, заменить пустую палитру своей, и чуть-чуть подменить цвета в графическом редакторе:<br /><img src="Pal5.png" alt="Pal5.png" /><br />Вроде симпатично получилось =)</p></li>
<li><p><strong>Спрайтовые Палитры</strong><br />В сущности, спрайтовые палитры мало чем отличаются от палитры картинок. Непосредственно палитра, как уже было сказано, хранится по адресам $3F10 - $3F1F и правила её нахождения и изменения абсолютно такие же, как и для палитры картинок. Чуть по-другому организовано понятие атрибутов спрайтов.<br />Внутри PPU есть отдельно адресуемая (от основного адресного пространства PPU - 16k) память спрайтов, размером 256 байт. Эта память хранит “записи” о 64 спрайтах, размер каждой записи 4 байта. Первый байт - координата по вертикали второй - индекс спрайта, третий - искомый нами атрибут, четвёртый - координата по горизонтали. Так как атрибут присвоит каждому спрайту в отдельности, то появляется возможность выделять под номер части палитры не весь байт, а только младшие два бита. Остальные биты отданы под другие атрибуты: например, отражение и приоритет спрайта. Фактически, поиск атрибута спрайта будет сводиться к нахождению спрайтового буфера и нахождению нужного нам спрайта, а следующий за индексом спрайта байт будет являться искомым байтом атрибута.<br />Итак, предположим, что нам нужно поменять цвет головы главного героя: у обычных зайцев он, вроде, серый =) Находим часть палитры, которой присвоен наш спрайт. Это вполне можно сделать и визуально (уж точно быстрее), однако в обучающих целях попробуем найти эту часть через атрибут спрайта. Находим спрайтовый буфер (эта операция описана в доке CaH4e3’a) - здесь он расположен по адресу $200. Находим индекс нашего спрайта (хотя в памяти PPU несколько голов - нужная нам голова имеет индекс $03) по адресу $0215. Соответственно, атрибут будет $02 = 00000010b, это означает, что тайлу головы присвоена третья часть палитры, так как младшие два бита составляют двойку в десятичной системе. И теперь попробуем поменять эту часть палитры. Поиск всей палитры производится так же, как и для картинок. Правда, в нашем случае палитры спрайтов хранятся несколько иначе, чем палитры картинок, но принципиально поиск ничем не отличается от описанного выше. Последние 8 цветов палитры хранятся по адресам РОМа $11c3d - $11c44. Наш зелёный ($29) цвет по адресу $11c40 заменяем на нормальный серый ($2D)цвет: <img src="Pal6.png" alt="Pal6.png" /><br />При необходимости можно переназначить голову на другие части палитры, однако не стоит забывать, что голова состоит не из одного тайла, т.е. переназначать на другие части придётся и другие тайлы, составляющие голову (уши и прочее).</p></li>
</ol>
<div id="disqus_thread"></div>
<script type="text/javascript">   
    var disqus_shortname = 'romhack'; // required: replace example with your forum shortname
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript><pre>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></pre></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


<hr />
<div id="w3c"><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a>
 <a href="http://jigsaw.w3.org/css-validator/check/referer"> <img src="http://jigsaw.w3.org/css-validator/images/vcss" alt="Valid CSS" height="31" width="88" /></a></div>
</div></body></html>



